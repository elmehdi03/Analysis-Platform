================================================================================
    TP PRATIQUE - PLATEFORME D'ANALYSE BIG DATA AVEC JEE/JAKARTA EE
                        DurÃ©e : 3 heures
================================================================================

OBJECTIF DU TP
--------------
DÃ©velopper une application complÃ¨te d'analyse Big Data pour une plateforme 
de streaming vidÃ©o simulÃ©e. L'application doit ingÃ©rer, traiter et analyser 
des millions d'Ã©vÃ©nements de visualisation en temps rÃ©el.


CONTEXTE
--------
Vous Ãªtes dÃ©veloppeur dans une startup de streaming vidÃ©o. La plateforme gÃ©nÃ¨re :
- 1000 Ã©vÃ©nements de visualisation par seconde
- MÃ©tadonnÃ©es de 10 000 vidÃ©os
- 50 000 utilisateurs actifs

Vous devez construire un systÃ¨me d'analyse qui :
1. IngÃ¨re les Ã©vÃ©nements en temps rÃ©el
2. Calcule des statistiques (vues, durÃ©e moyenne, vidÃ©os populaires)
3. GÃ©nÃ¨re des recommandations personnalisÃ©es
4. Affiche un dashboard temps rÃ©el


ARCHITECTURE Ã€ RÃ‰ALISER
------------------------

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                     â”‚
â”‚  [Data Generator] â†’ [Kafka/Queue] â†’ [Stream Processor]             â”‚
â”‚                                              â†“                      â”‚
â”‚                                        [MongoDB/NoSQL]              â”‚
â”‚                                              â†“                      â”‚
â”‚                                        [REST API - JEE]             â”‚
â”‚                                              â†“                      â”‚
â”‚                                        [Dashboard JSP/MVC]          â”‚
â”‚                                                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


================================================================================
PARTIE 1 : CONFIGURATION ET INFRASTRUCTURE (30 MIN)
================================================================================

TÃ‚CHE 1.1 - CrÃ©er le projet Maven
----------------------------------
Structure attendue :

streaming-analytics/
â”œâ”€â”€ data-generator/          (module gÃ©nÃ©rateur de donnÃ©es)
â”œâ”€â”€ analytics-api/           (module API REST JEE)
â”œâ”€â”€ analytics-dashboard/     (module Dashboard Web)
â””â”€â”€ pom.xml                  (parent POM)

DÃ©pendances Maven requises :
- Jakarta EE 10
- MongoDB Driver / Hibernate OGM
- JAX-RS (REST)
- CDI
- JPA
- Servlet/JSP
- JSON-B ou Jackson

CrÃ©ez la structure de projet avec les pom.xml appropriÃ©s.


TÃ‚CHE 1.2 - Docker Compose Infrastructure
------------------------------------------
CrÃ©ez un docker-compose.yml qui lance :
- MongoDB (port 27017)
- Kafka + Zookeeper (optionnel, peut Ãªtre remplacÃ© par file queue)
- Votre application JEE (Wildfly/Payara/TomEE)

Vous recevrez le fichier docker-compose.yml de base Ã  complÃ©ter.


================================================================================
PARTIE 2 : GÃ‰NÃ‰RATEUR DE DONNÃ‰ES (20 MIN)
================================================================================

FOURNI : Code Java complet pour gÃ©nÃ©rer des donnÃ©es simulÃ©es

Le gÃ©nÃ©rateur produit des Ã©vÃ©nements JSON comme :

{
  "eventId": "evt_123456",
  "userId": "user_789",
  "videoId": "video_456",
  "timestamp": "2024-01-15T14:30:00Z",
  "action": "WATCH",
  "duration": 245,
  "quality": "1080p",
  "deviceType": "mobile"
}

VOTRE MISSION :
ExÃ©cutez le gÃ©nÃ©rateur pour produire 100 000 Ã©vÃ©nements dans un fichier JSON
ou les envoyer vers Kafka/une queue.


================================================================================
PARTIE 3 : MODÃˆLE DE DONNÃ‰ES ET PERSISTANCE (40 MIN)
================================================================================

TÃ‚CHE 3.1 - CrÃ©er les entitÃ©s JPA/NoSQL
----------------------------------------

Ã€ CRÃ‰ER :

1. EntitÃ© Event (Ã©vÃ©nement de visualisation)
   - Attributs : eventId, userId, videoId, timestamp, action, duration, quality, deviceType
   - Annotations JPA ou Hibernate OGM pour MongoDB
   - Index sur userId, videoId, timestamp

2. EntitÃ© VideoStats (statistiques agrÃ©gÃ©es par vidÃ©o)
   - Attributs : videoId, totalViews, avgDuration, lastUpdated
   - Ã€ calculer en temps rÃ©el

3. EntitÃ© UserProfile (profil utilisateur)
   - Attributs : userId, watchHistory, preferences, recommendedVideos

4. EntitÃ© Video (mÃ©tadonnÃ©es vidÃ©o)
   - Attributs : videoId, title, category, duration, uploadDate


TÃ‚CHE 3.2 - CrÃ©er les Repositories avec CDI
--------------------------------------------

Ã€ CRÃ‰ER :

@ApplicationScoped
public class EventRepository {
    // Injection EntityManager ou MongoClient
    // MÃ©thode : save(Event)
    // MÃ©thode : findByUserId(String userId)
    // MÃ©thode : findByVideoId(String videoId)
    // MÃ©thode : findByTimeRange(Date start, Date end)
}

@ApplicationScoped
public class VideoStatsRepository {
    // MÃ©thode : updateStats(String videoId, ViewEvent event)
    // MÃ©thode : getTopVideos(int limit)
    // MÃ©thode : getStats(String videoId)
}

Utilisez CDI pour l'injection de dÃ©pendances.


================================================================================
PARTIE 4 : TRAITEMENT BIG DATA (50 MIN)
================================================================================

TÃ‚CHE 4.1 - Service de Traitement des Ã‰vÃ©nements
-------------------------------------------------

CrÃ©ez un service qui :

@ApplicationScoped
public class EventProcessorService {
    
    @Inject
    EventRepository eventRepository;
    
    @Inject
    VideoStatsRepository statsRepository;
    
    /**
     * Traite un Ã©vÃ©nement de visualisation
     * 1. Sauvegarde l'Ã©vÃ©nement
     * 2. Met Ã  jour les statistiques vidÃ©o
     * 3. Met Ã  jour le profil utilisateur
     */
    public void processEvent(ViewEvent event) {
        // VOTRE CODE ICI
    }
    
    /**
     * Calcule les vidÃ©os populaires (top 10)
     */
    public List<VideoStats> getTopVideos() {
        // VOTRE CODE ICI
    }
    
    /**
     * GÃ©nÃ¨re des recommandations pour un utilisateur
     * BasÃ© sur : historique, vidÃ©os populaires dans sa catÃ©gorie
     */
    public List<Video> getRecommendations(String userId) {
        // VOTRE CODE ICI
    }
}


TÃ‚CHE 4.2 - Traitement Batch (MapReduce-like)
----------------------------------------------

CrÃ©ez une tÃ¢che qui calcule des statistiques agrÃ©gÃ©es :

@ApplicationScoped
public class AnalyticsService {
    
    /**
     * Calcule les statistiques par catÃ©gorie de vidÃ©o
     * Utilise des requÃªtes d'agrÃ©gation MongoDB ou JPQL
     */
    public Map<String, CategoryStats> aggregateByCategory() {
        // GROUP BY category
        // COUNT, AVG, SUM
    }
    
    /**
     * DÃ©tecte les tendances (vidÃ©os avec croissance rapide)
     * Compare vues derniÃ¨res 24h vs semaine prÃ©cÃ©dente
     */
    public List<Video> detectTrending() {
        // VOTRE CODE ICI
    }
}


================================================================================
PARTIE 5 : API REST HAUTE PERFORMANCE (40 MIN)
================================================================================

TÃ‚CHE 5.1 - Endpoints REST avec JAX-RS
---------------------------------------

CrÃ©ez les endpoints suivants :

@Path("/api/v1/analytics")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public class AnalyticsResource {
    
    @Inject
    EventProcessorService processor;
    
    // POST /api/v1/analytics/events
    // IngÃ¨re un nouvel Ã©vÃ©nement
    @POST
    @Path("/events")
    public Response ingestEvent(ViewEvent event) {
        // VOTRE CODE ICI
    }
    
    // POST /api/v1/analytics/events/batch
    // IngÃ¨re un lot d'Ã©vÃ©nements (bulk insert)
    @POST
    @Path("/events/batch")
    public Response ingestBatch(List<ViewEvent> events) {
        // VOTRE CODE ICI
        // Optimisation : batch insert
    }
    
    // GET /api/v1/analytics/videos/top
    // Retourne les 10 vidÃ©os les plus vues
    @GET
    @Path("/videos/top")
    public Response getTopVideos(@QueryParam("limit") int limit) {
        // VOTRE CODE ICI
    }
    
    // GET /api/v1/analytics/videos/{videoId}/stats
    // Statistiques pour une vidÃ©o spÃ©cifique
    @GET
    @Path("/videos/{videoId}/stats")
    public Response getVideoStats(@PathParam("videoId") String videoId) {
        // VOTRE CODE ICI
    }
    
    // GET /api/v1/analytics/users/{userId}/recommendations
    // Recommandations personnalisÃ©es
    @GET
    @Path("/users/{userId}/recommendations")
    public Response getRecommendations(@PathParam("userId") String userId) {
        // VOTRE CODE ICI
    }
    
    // GET /api/v1/analytics/realtime/stream
    // Stream SSE des statistiques temps rÃ©el
    @GET
    @Path("/realtime/stream")
    @Produces(MediaType.SERVER_SENT_EVENTS)
    public void streamRealtime(@Context SseEventSink sseEventSink) {
        // VOTRE CODE ICI
        // Envoie des stats toutes les 2 secondes
    }
}


TÃ‚CHE 5.2 - Optimisations Performance
--------------------------------------

ImplÃ©mentez :

1. Cache avec @CacheResult (optionnel si le temps le permet)
   - Cache des top vidÃ©os (TTL 60 secondes)
   - Cache des stats vidÃ©o (TTL 30 secondes)

2. Pagination pour les requÃªtes volumineuses
   - Cursor-based pagination
   - ParamÃ¨tres : limit, offset ou cursor

3. Compression GZIP pour les rÃ©ponses
   - Intercepteur JAX-RS


================================================================================
PARTIE 6 : DASHBOARD WEB MVC (40 MIN)
================================================================================

TÃ‚CHE 6.1 - Servlet ContrÃ´leur
-------------------------------

CrÃ©ez le contrÃ´leur MVC :

@WebServlet("/dashboard")
public class DashboardServlet extends HttpServlet {
    
    @Inject
    EventProcessorService processor;
    
    @Inject
    AnalyticsService analytics;
    
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) {
        // 1. RÃ©cupÃ©rer les donnÃ©es
        List<VideoStats> topVideos = processor.getTopVideos();
        Map<String, CategoryStats> categoryStats = analytics.aggregateByCategory();
        
        // 2. Passer Ã  la vue
        req.setAttribute("topVideos", topVideos);
        req.setAttribute("categoryStats", categoryStats);
        
        // 3. Forward vers JSP
        req.getRequestDispatcher("/WEB-INF/views/dashboard.jsp").forward(req, resp);
    }
}


TÃ‚CHE 6.2 - Vue JSP avec JSTL
------------------------------

CrÃ©ez dashboard.jsp :

<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>
<%@ taglib uri="http://java.sun.com/jsp/jstl/fmt" prefix="fmt" %>

<!DOCTYPE html>
<html>
<head>
    <title>Analytics Dashboard</title>
    <style>
        /* CSS fourni sÃ©parÃ©ment */
    </style>
</head>
<body>
    <h1>ğŸ“Š Analytics Dashboard - Streaming Platform</h1>
    
    <section id="top-videos">
        <h2>ğŸ”¥ Top 10 Videos</h2>
        <table>
            <thead>
                <tr>
                    <th>Video ID</th>
                    <th>Total Views</th>
                    <th>Avg Duration</th>
                    <th>Last Updated</th>
                </tr>
            </thead>
            <tbody>
                <c:forEach items="${topVideos}" var="video">
                    <tr>
                        <td>${video.videoId}</td>
                        <td><fmt:formatNumber value="${video.totalViews}"/></td>
                        <td>${video.avgDuration}s</td>
                        <td><fmt:formatDate value="${video.lastUpdated}" pattern="HH:mm:ss"/></td>
                    </tr>
                </c:forEach>
            </tbody>
        </table>
    </section>
    
    <section id="category-stats">
        <h2>ğŸ“‚ Stats by Category</h2>
        <!-- Ã€ COMPLÃ‰TER : Graphiques avec Chart.js ou Ã©quivalent -->
    </section>
    
    <section id="realtime">
        <h2>âš¡ Real-time Events</h2>
        <div id="event-stream">
            <!-- Flux SSE ici -->
        </div>
    </section>
    
    <script>
        // JavaScript pour SSE
        const eventSource = new EventSource('/api/v1/analytics/realtime/stream');
        eventSource.onmessage = function(event) {
            const data = JSON.parse(event.data);
            // Mettre Ã  jour le dashboard
        };
    </script>
</body>
</html>


================================================================================
TESTS ET VALIDATION (RESTE DU TEMPS)
================================================================================

TESTS Ã€ EFFECTUER :

1. GÃ©nÃ©rer 100 000 Ã©vÃ©nements avec le data generator

2. Tester l'API REST avec curl ou Postman :
   - POST /api/v1/analytics/events/batch (insÃ©rer 1000 Ã©vÃ©nements)
   - GET /api/v1/analytics/videos/top
   - GET /api/v1/analytics/users/user_123/recommendations

3. Ouvrir le dashboard et vÃ©rifier :
   - Les top vidÃ©os s'affichent
   - Les stats se mettent Ã  jour
   - Le flux temps rÃ©el fonctionne

4. Mesurer les performances :
   - Temps d'insertion de 1000 Ã©vÃ©nements
   - Temps de calcul des top vidÃ©os
   - Latence des requÃªtes API


MÃ‰TRIQUES DE SUCCÃˆS :
- Ingestion : > 500 Ã©vÃ©nements/seconde
- Lecture top vidÃ©os : < 100ms
- Recommandations : < 200ms
- Dashboard : rafraÃ®chissement < 2 secondes


================================================================================
LIVRABLES
================================================================================

Ã€ la fin du TP, vous devez avoir :

1. âœ… Code source complet (Maven project)
2. âœ… Base de donnÃ©es MongoDB avec 100K Ã©vÃ©nements
3. âœ… API REST fonctionnelle (testÃ©e avec Postman/curl)
4. âœ… Dashboard web accessible
5. âœ… README.md avec instructions de dÃ©ploiement
6. âœ… Capture d'Ã©cran du dashboard


BONUS (si le temps le permet) :
- Docker Compose complet
- Tests unitaires (JUnit)
- DÃ©tection d'anomalies (ex: pic soudain de vues)
- Cache Redis pour performance


================================================================================
RESSOURCES FOURNIES
================================================================================

Vous trouverez dans le dossier "resources/" :

1. data-generator.zip
   - DataGenerator.java (gÃ©nÃ©rateur d'Ã©vÃ©nements)
   - pom.xml configurÃ©
   - Script de lancement

2. docker-compose-base.yml
   - Configuration MongoDB
   - Configuration Kafka (optionnel)

3. pom-parent.xml
   - DÃ©pendances Maven prÃ©-configurÃ©es

4. dashboard-style.css
   - Styles CSS pour le dashboard

5. postman-collection.json
   - Collection de tests API


================================================================================
NOTATION (20 POINTS)
================================================================================

Persistance et ModÃ¨le (Partie 3)      : 4 points
Traitement Big Data (Partie 4)        : 5 points
API REST (Partie 5)                   : 5 points
Dashboard MVC (Partie 6)              : 4 points
Tests et Performance                  : 2 points
                                      â”€â”€â”€â”€â”€â”€â”€â”€â”€
TOTAL                                 : 20 points


CRITÃˆRES DÃ‰TAILLÃ‰S :

Architecture et Design Patterns       : /4
  - CDI correctement utilisÃ©
  - SÃ©paration des responsabilitÃ©s
  - Repository pattern

QualitÃ© du Code                       : /4
  - Code propre et commentÃ©
  - Gestion des erreurs
  - Optimisations

FonctionnalitÃ©s                       : /8
  - Ingestion de donnÃ©es
  - Calcul de statistiques
  - Recommandations
  - Dashboard temps rÃ©el

Performance                           : /2
  - MÃ©triques atteintes
  - Optimisations implÃ©mentÃ©es

Documentation                         : /2
  - README clair
  - Commentaires pertinents


================================================================================
BON TRAVAIL !
================================================================================
